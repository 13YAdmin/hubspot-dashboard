#!/usr/bin/env node

/**
 * AGENT DEBUGGER - DÃ©buggeur qui rÃ©pare les tests qui Ã©chouent
 *
 * RESPONSABILITÃ‰S:
 * - Lire le rapport de l'Agent QA
 * - Identifier les tests qui Ã©chouent
 * - Fixer les bugs dÃ©tectÃ©s
 * - Re-lancer QA pour valider
 */

const fs = require('fs');
const path = require('path');

class AgentDebugger {
  constructor() {
    this.dashboardPath = path.join(process.cwd(), 'public/index.html');
    this.qaReportPath = path.join(process.cwd(), 'RAPPORT-AGENT-QA.md');
    this.fixes = [];
  }

  log(message) {
    console.log(`ğŸ› [AGENT DEBUGGER] ${message}`);
  }

  async run() {
    this.log('DÃ‰MARRAGE - Debugger');
    console.log('================================================\n');

    // 1. Lire le rapport QA
    if (!fs.existsSync(this.qaReportPath)) {
      this.log('âŒ Pas de rapport QA trouvÃ©. Lancer Agent QA d\'abord.');
      return;
    }

    const qaReport = fs.readFileSync(this.qaReportPath, 'utf8');
    const failedTests = this.parseFailedTests(qaReport);

    if (failedTests.length === 0) {
      this.log('âœ… Aucun test Ã©chouÃ©. Dashboard OK!');
      return;
    }

    this.log(`ğŸ” ${failedTests.length} tests Ã©chouÃ©s dÃ©tectÃ©s\n`);

    // 2. Fixer les bugs
    const content = fs.readFileSync(this.dashboardPath, 'utf8');
    const fixedContent = await this.applyFixes(content, failedTests);

    // 3. Sauvegarder
    if (fixedContent !== content) {
      fs.writeFileSync(this.dashboardPath, fixedContent, 'utf8');
      this.log('\nâœ… Fixes appliquÃ©s et sauvegardÃ©s');
    }

    // 4. Rapport
    await this.generateReport();

    this.log('âœ… Agent Debugger terminÃ©');
  }

  parseFailedTests(report) {
    const lines = report.split('\n');
    const failed = [];

    lines.forEach(line => {
      if (line.includes('âŒ')) {
        // Extraire le nom du test
        const match = line.match(/âŒ\s+(.+?)(?:\s+-\s+|$)/);
        if (match) {
          failed.push(match[1].trim());
        }
      }
    });

    return failed;
  }

  async applyFixes(content, failedTests) {
    this.log('ğŸ”§ APPLICATION DES FIXES...\n');
    let fixed = content;

    failedTests.forEach(test => {
      this.log(`Fixing: ${test}`);

      // Fix #1: Fonctions non exposÃ©es
      if (test.includes('exposÃ©e')) {
        const funcName = test.split(' ')[0];
        if (!fixed.includes(`window.${funcName} =`)) {
          // Chercher la fonction et ajouter window.X = X aprÃ¨s
          const regex = new RegExp(`(function ${funcName}\\([^)]*\\)[^}]*\\}\\n)`, 'm');
          if (regex.test(fixed)) {
            fixed = fixed.replace(regex, `$1window.${funcName} = ${funcName};\n`);
            this.fixes.push(`Exposed ${funcName} globally`);
            this.log(`   âœ… ${funcName} exposÃ©`);
          }
        }
      }

      // Fix #2: Graphiques non appelÃ©s
      if (test.includes('appelÃ©')) {
        const funcName = test.split(' ')[0];
        if (!fixed.includes(`${funcName}();`)) {
          // Ajouter dans renderDashboard()
          const renderDashboardMatch = fixed.match(/(function renderDashboard\(\)[^}]*\{[\s\S]*?)(\/\/\s*===\s*FIN|}\s*function\s)/);
          if (renderDashboardMatch) {
            const insertion = `  ${funcName}();\n`;
            fixed = fixed.replace(renderDashboardMatch[0], renderDashboardMatch[1] + insertion + renderDashboardMatch[2]);
            this.fixes.push(`Added ${funcName}() call in renderDashboard()`);
            this.log(`   âœ… ${funcName}() ajoutÃ©`);
          }
        }
      }
    });

    return fixed;
  }

  async generateReport() {
    const report = `# ğŸ› RAPPORT AGENT DEBUGGER

**Date**: ${new Date().toLocaleString('fr-FR')}

## ğŸ“Š RÃ‰SUMÃ‰

- Fixes appliquÃ©s: ${this.fixes.length}

## ğŸ”§ DÃ‰TAILS

${this.fixes.map((f, i) => `${i + 1}. ${f}`).join('\n')}

## ğŸ¯ PROCHAINES Ã‰TAPES

${this.fixes.length > 0
  ? '- Re-lancer Agent QA pour valider\n- Si tests OK â†’ dÃ©ployer\n- Si tests KO â†’ re-dÃ©bugger'
  : '- Tous les bugs dÃ©jÃ  fixÃ©s'}

---

ğŸ¤– Generated by Agent Debugger
`;

    fs.writeFileSync('RAPPORT-AGENT-DEBUGGER.md', report);
    this.log('\nğŸ“ Rapport gÃ©nÃ©rÃ©: RAPPORT-AGENT-DEBUGGER.md');
  }
}

// ExÃ©cution
if (require.main === module) {
  const agent = new AgentDebugger();
  agent.run().catch(console.error);
}

module.exports = AgentDebugger;

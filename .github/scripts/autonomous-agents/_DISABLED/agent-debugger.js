#!/usr/bin/env node

/**
 * AGENT DEBUGGER - Débuggeur qui répare les tests qui échouent
 *
 * RESPONSABILITÉS:
 * - Lire le rapport de l'Agent QA
 * - Identifier les tests qui échouent
 * - Fixer les bugs détectés
 * - Re-lancer QA pour valider
 */

const fs = require('fs');
const path = require('path');

class AgentDebugger {
  constructor() {
    this.dashboardPath = path.join(process.cwd(), 'public/index.html');
    this.qaReportPath = path.join(process.cwd(), 'RAPPORT-AGENT-QA.md');
    this.fixes = [];
  }

  log(message) {
    console.log(`🐛 [AGENT DEBUGGER] ${message}`);
  }

  async run() {
    this.log('DÉMARRAGE - Debugger');
    console.log('================================================\n');

    // 1. Lire le rapport QA
    if (!fs.existsSync(this.qaReportPath)) {
      this.log('❌ Pas de rapport QA trouvé. Lancer Agent QA d\'abord.');
      return;
    }

    const qaReport = fs.readFileSync(this.qaReportPath, 'utf8');
    const failedTests = this.parseFailedTests(qaReport);

    if (failedTests.length === 0) {
      this.log('✅ Aucun test échoué. Dashboard OK!');
      return;
    }

    this.log(`🔍 ${failedTests.length} tests échoués détectés\n`);

    // 2. Fixer les bugs
    const content = fs.readFileSync(this.dashboardPath, 'utf8');
    const fixedContent = await this.applyFixes(content, failedTests);

    // 3. Sauvegarder
    if (fixedContent !== content) {
      fs.writeFileSync(this.dashboardPath, fixedContent, 'utf8');
      this.log('\n✅ Fixes appliqués et sauvegardés');
    }

    // 4. Rapport
    await this.generateReport();

    this.log('✅ Agent Debugger terminé');
  }

  parseFailedTests(report) {
    const lines = report.split('\n');
    const failed = [];

    lines.forEach(line => {
      if (line.includes('❌')) {
        // Extraire le nom du test
        const match = line.match(/❌\s+(.+?)(?:\s+-\s+|$)/);
        if (match) {
          failed.push(match[1].trim());
        }
      }
    });

    return failed;
  }

  async applyFixes(content, failedTests) {
    this.log('🔧 APPLICATION DES FIXES...\n');
    let fixed = content;

    failedTests.forEach(test => {
      this.log(`Fixing: ${test}`);

      // Fix #1: Fonctions non exposées
      if (test.includes('exposée')) {
        const funcName = test.split(' ')[0];
        if (!fixed.includes(`window.${funcName} =`)) {
          // Chercher la fonction et ajouter window.X = X après
          const regex = new RegExp(`(function ${funcName}\\([^)]*\\)[^}]*\\}\\n)`, 'm');
          if (regex.test(fixed)) {
            fixed = fixed.replace(regex, `$1window.${funcName} = ${funcName};\n`);
            this.fixes.push(`Exposed ${funcName} globally`);
            this.log(`   ✅ ${funcName} exposé`);
          }
        }
      }

      // Fix #2: Graphiques non appelés
      if (test.includes('appelé')) {
        const funcName = test.split(' ')[0];
        if (!fixed.includes(`${funcName}();`)) {
          // Ajouter dans renderDashboard()
          const renderDashboardMatch = fixed.match(/(function renderDashboard\(\)[^}]*\{[\s\S]*?)(\/\/\s*===\s*FIN|}\s*function\s)/);
          if (renderDashboardMatch) {
            const insertion = `  ${funcName}();\n`;
            fixed = fixed.replace(renderDashboardMatch[0], renderDashboardMatch[1] + insertion + renderDashboardMatch[2]);
            this.fixes.push(`Added ${funcName}() call in renderDashboard()`);
            this.log(`   ✅ ${funcName}() ajouté`);
          }
        }
      }
    });

    return fixed;
  }

  async generateReport() {
    const report = `# 🐛 RAPPORT AGENT DEBUGGER

**Date**: ${new Date().toLocaleString('fr-FR')}

## 📊 RÉSUMÉ

- Fixes appliqués: ${this.fixes.length}

## 🔧 DÉTAILS

${this.fixes.map((f, i) => `${i + 1}. ${f}`).join('\n')}

## 🎯 PROCHAINES ÉTAPES

${this.fixes.length > 0
  ? '- Re-lancer Agent QA pour valider\n- Si tests OK → déployer\n- Si tests KO → re-débugger'
  : '- Tous les bugs déjà fixés'}

---

🤖 Generated by Agent Debugger
`;

    fs.writeFileSync('RAPPORT-AGENT-DEBUGGER.md', report);
    this.log('\n📝 Rapport généré: RAPPORT-AGENT-DEBUGGER.md');
  }
}

// Exécution
if (require.main === module) {
  const agent = new AgentDebugger();
  agent.run().catch(console.error);
}

module.exports = AgentDebugger;
